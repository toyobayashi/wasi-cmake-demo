<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <script type="module">
      (async () => {
        class OutputStream {
          constructor (size) {
            this._buf = new Uint8Array(size)
            this._pos = 0
          }

          write (buffer) {
            this._buf.set(buffer, this._pos)
            this._pos += buffer.byteLength
          }
        }

        class StandardOutput extends OutputStream {
          constructor (size, print) {
            super(size)
            this._print = print
          }
          write (buffer) {
            super.write(buffer)
            let index
            while ((index = this._buf.indexOf(10)) !== -1) {
              const str = new TextDecoder().decode(this._buf.subarray(0, index))
              this._print(str)
              this._buf.set(this._buf.subarray(index + 1, this._pos))
              this._pos -= (index + 1)
              this._buf.fill(0, this._pos)
            }
          }
        }

        const streams = [
          undefined,
          new StandardOutput(1024, console.log),
          new StandardOutput(1024, console.error)
        ]

        const memory = new WebAssembly.Memory({ initial: 256 })
        
        function getMemory() {
          return {
            HEAPU8: new Uint8Array(memory.buffer),
            HEAPU16: new Uint16Array(memory.buffer),
            HEAP32: new Int32Array(memory.buffer),
            HEAPU32: new Uint32Array(memory.buffer)
          }
        }

        const args = ['node', 'index.js']
        const argBuf = new TextEncoder().encode(args.join('\0') + '\0')

        const response = await fetch('./build/a.wasm')
        const bytes = await response.arrayBuffer()
        const { instance } = await WebAssembly.instantiate(bytes, {
          env: {
            memory,
            call_js (f) {
              __indirect_function_table.get(f)()
            }
          },
          wasi_snapshot_preview1: {
            proc_exit (rval) {
              console.log(`proc_exit(${rval});`)
            },
            args_get (argv, argv_buf) {
              const { HEAPU8, HEAP32, HEAPU32 } = getMemory()
              HEAP32[argv >> 2] = argv_buf
              for (let i = 1; i < args.length; ++i) {
                HEAP32[(argv >> 2) + i] = argv_buf + new TextEncoder().encode(args.slice(0, i).join('\0') + '\0').length
              }
              HEAPU8.set(argBuf, argv_buf)
              return 0
            },
            args_sizes_get (argc, argv_buf_size) {
              const { HEAP32, HEAPU32 } = getMemory()
              HEAP32[argc >> 2] = args.length
              HEAPU32[argv_buf_size >> 2] = argBuf.length
              return 0
            },
            fd_close (fd) {
              return 0
            },
            fd_fdstat_get (fd, fdstat) {
              return 0
            },
            fd_seek (fd, offset, whence, filesize) {
              return 0
            },
            fd_write (fd, iovs, iovslen, size) {
              const { HEAPU8, HEAP32, HEAPU32 } = getMemory()
              let nwritten = 0
              const stream = streams[fd]
              for (let i = 0; i < iovslen; ++i) {
                const buf = HEAP32[(iovs + (i * 8)) >> 2]
                const bufLen = HEAPU32[((iovs + (i * 8)) >> 2) + 1]
                if (bufLen === 0) continue

                if (stream) {
                  const data = HEAPU8.subarray(buf, buf + bufLen)
                  stream.write(data)
                }
                nwritten += bufLen
              }

              HEAPU32[size >> 2] = nwritten
              return 0
            }
          }
        })

        console.log(instance.exports)
        const {
          _start,
          malloc,
          free,
          base64_encode,
          base64_decode,
          __indirect_function_table
        } = instance.exports

        if (typeof _start === 'function') {
          _start()
        }

        function b64Encode (data) {
          let buffer
          if (typeof data === 'string') {
            buffer = new TextEncoder().encode(data)
          } else if (ArrayBuffer.isView(data)) {
            buffer = new Uint8Array(data.buffer, data.byteOffset, data.byteLength)
          } else {
            throw new TypeError('Invalid data')
          }

          const buf = malloc(buffer.length)
          if (buf === 0) throw new Error('malloc failed')
          const { HEAPU8, HEAPU32 } = getMemory()
          HEAPU8.set(buffer, buf)
          let size = base64_encode(buf, buffer.length, 0)
          if (size === 0) {
            free(buf)
            throw new Error('encode failed')
          }
          const res = malloc(size)
          if (res === 0) {
            free(buf)
            throw new Error('malloc failed')
          }
          size = base64_encode(buf, buffer.length, res)
          free(buf)
          const str = new TextDecoder().decode(HEAPU8.subarray(res, res + size))
          free(res)
          return str
        }

        function b64Decode (str) {
          const buffer = new TextEncoder().encode(str)
          const buf = malloc(buffer.length)
          if (buf === 0) throw new Error('malloc failed')
          const { HEAPU8, HEAPU32 } = getMemory()
          HEAPU8.set(buffer, buf)
          let size = base64_decode(buf, buffer.length, 0)
          if (size === 0) {
            free(buf)
            throw new Error('decode failed')
          }
          const res = malloc(size)
          if (res === 0) {
            free(buf)
            throw new Error('malloc failed')
          }
          size = base64_decode(buf, buffer.length, res)
          free(buf)
          const arr = HEAPU8.slice(res, res + size)
          free(res)
          return arr
        }

        const input = 'Hello wasi\n'
        const b64Str = b64Encode(input)
        console.log(b64Str)
        const origin = b64Decode(b64Str)
        const originStr = new TextDecoder().decode(origin)
        console.log(originStr === input)
      })()
    </script>
  </body>
</html>
